
## 용어 정리
**도메인**
> 문제를 해결하기 위해 사용자가 프로그램을 사용하는 분야

**Template Method Pattern**
> 부모 클래스에 기본적인 알고리즘 흐름을 구현하고 중간에 필요한 처리를 자식 클래스에게 위임하는 디자인패턴

**지연 바인딩(Lazy Binding), 동적 바인딩(Dynamic Binding)**
> 메시지에 응답하기 위해 실행될 메서드를 컴파일 시점이 아닌 실행 시점에 결정
## 설계 고려 사항
- 어떤 클래스가 필요한지 고민하기 전에 어떤 객체들이 필요한지 고민하기
    - 어떤 객체들이 어떠한 상태와 행동을 가지는지에 대해 먼저 생각하기
- 객체는 독립적인 존재가 아니라 기능을 구현하기 위해 협력하는 공동체의 일원으로 봐야 함
- 지연 바인딩 적용
  - 컴파일 시점의 의존성과 실행 시점의 의존성 분리
- 일급 컬렉션 사용
  - 하나의 인스턴스 변수만 포함하더라도 의미를 분명하게 표현할 수 있다면 객체를 사용해 구현
  - 금액을 단순히 Long 타입으로 지정할 수 있지만, 값이 금액과 관련이 있다는 의미를 전달할 수 없음
  - 금액 관련 로직이 서로 다른 곳에 중복 구현되는 것을 막을 수 없음
  - 의미를 좀 더 명시적이고 분명하게 표현할 수 있다면 객체를 사용해 개념을 표현하는 것이 전체적 설계의 명확성과 유연성을 높이는 첫걸음
- 상속보다는 합성을 적용
  - 합성은 `Movie`가 `DiscountPolicy` 코드를 재사용하는 것과 같은 방법을 의미
- 할인 정책이 없는 경우인 `NoneDiscountPolicy`는 약간 다른 방식으로 구현
  - 따로 클래스 추가 구현 없이 `Movie` 클래스에서 정책이 없을 경우에 대한 처리 로직을 추가할 수 있지만, `Movie`에 대한 책임이 커짐
  - 단순히 `DiscountPolicy` 추상 클래스를 구현할 경우 `getDiscountAmount()` 메서드가 호출되지 않음(불필요한 코드)
  - `calculateDiscountAmount()` 메서드를 갖는 인터페이스를 생성하고, `DiscountPolicy` 추상 클래스가 해당 인터페이스를 구현하도록 수정

---
**상속**
- 코드 재사용을 위해 널리 사용되는 기법
- 캡슐화를 위반할 수 있음
  - 부모 클래스의 구현이 자식 클래스에게 노출되어 캡슐화가 약화됨
  - 부모 클래스와 자식 클래스 간 결합도가 매우 강해짐
- 유연하지 않은 설계의 원인이 될 수 있음
  - 만약 실행 시점에 할인 정책을 변경해야 한다면 코드 수정이 번거로워짐

**합성**
- 인터페이스에 정의된 메시지를 통해서만 재사용이 가능해 구현을 효과적으로 캡슐화
- 객체 간 결합도를 낮출 수 있음

