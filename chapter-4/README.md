**설계**
- 설계는 변경을 위해 존재한다고도 볼 수 있음
- 훌륭한 설계란 합리적인 비용 안에서 변경을 수용할 수 있는 구조를 만드는 것
- 적절한 비용 안에서 쉽게 변경할 수 있는 설계는 응집도가 높고 서로 느슨하게 결합되어 있는 요소로 구성됨
- 이를 위해 객체의 상태가 아니라 객체의 행동에 초점을 맞춰야 함

**결합도**
- 결합도가 높다고 무조건 잘못된 설계인 것은 아님
  - 변경될 확률이 매우 적은 안정적인 모듈에 의존하는 것이 큰 문제는 아님
  - 표준 라이브러리에 포함된 모듈, 성숙 단계인 프레임워크 등이 이에 속함 
---

> 객체를 단순한 데이터의 집합으로 바라보는 시각은 변경에 취약한 설계의 원인이 된다.


## 데이터 중심 설계
- **Movie의** 책임이 무엇인지 묻는 것이 아닌 Movie에 저장될 데이터가 무엇인지 먼저 생각함
    - Movie의 인스턴스 변수에 **discountConditions**, **Policy**, **MovieType이** 포함되는 설계를 낳음

- 객체가 사용될 협력을 고려하지 않았음
    - 객체가 다양한 상황에서 사용될 수 있는 것이라는 막연한 추측을 기반으로 설계
    - 그 결과 getter, setter가 무분별하게 구현됨
- **ReservationAgency**의 경우, 구현된 대부분의 데이터 객체에 의존함
- 객체 내부에 직접 접근하지 못하도록 **getter**, **setter** 구현
  - _캡슐화 원칙을 지키고 있는 것 처럼 보이지만 그렇지 않음_

## 캡슐화 위반 이유
- 접근 제어자 private와 getter, setter 적용이 캡슐화를 보장해주는 것은 아님
#### 예시
```
> 가로, 세로 길이를 인스턴스 변수로 갖는 Rectangle 클래스가 있고, 이에 대한 getter, setter만 구현되어 있다고 가정
> 다른 클래스에서 해당 Rectangle의 넓이를 구해야 한다면 getter를 이용해 길이를 얻어내 직접 계산해야 함
> 이 로직은 다른 곳에서도 필요할 수 있고, 코드가 중복됨
> Rectangle이 직접 넓이를 계산할 수 있도록 역할을 부여하는 것이 필요
```

## 데이터 중심 설계가 변경에 취약한 이유
- 설계 초기에 데이터에 관해 결정하도록 설계가 강요됨(초기에 내부 구현에 초점을 맞춘 설계)
  - 협력이라는 문맥을 고려하지 않고 객체를 고립시킨 채 설계했기 때문