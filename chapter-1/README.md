**결합도(coupling)**
> 객체 사이의 의존성에 대한 정도

**캡슐화(encapsulation)**
>개념적이나 물리적으로 객체 내부의 세부적인 사항을 감추는 것

**응집도(cohesion)**
> 밀접하게 연관된 작업만을 수행하고 연관성 없는 작업은 다른 객체에게 위임하는 정도
   
자신의 데이터를 스스로 처리하는 자율적인 객체를 만들면 결합도는 낮추고 응집도는 높일 수 있게 됨

---

## 각 step의 특징
### step - 1

- 현실에서는 관람객이 자신의 가방에서 초대장을 꺼내 판매원에게 건네지만, 현재의 코드는 이와 다르게 동작한다.
    - 관람객의 입장에서 소극장이라는 제 3자가 초대장 확인을 위해 관람객의 가방을 마음대로 열어본다.
    - 소극장은 판매자의 허락도 없이 매표소에 보관 중인 티켓과 현금에 마음대로 접근한다.
    - 즉, `Audience`, `TicketSeller`의 경우 `Theater`의 통제를 받는
      수동적인 존재로 구현된다.
- `Theater`와 다른 객체 간 결합도가 높다.
    - `Theater`가 `Audience`, `Bag`, 등 다른 객체의 세부 사항을 전부 알고 있어야 한다.
    - `Audience`와 `TicketSeller`가 변경될 경우, `Theater` 역시 변경되어야 한다.
    - `Theater`는 관람객의 가방, 판매원의 매표소 판매에 대한 동작에 대해 알 필요가 없다.
    - `Theater`는 관람객의 입장 여부만 확인하도록 설계해야 한다.

### step - 2
- 관람객과 판매원이 자율적인 존재로 동작하도록 구현
- 캡슐화의 목적은 변경하기 쉬운 객체를 만드는 것
- 캡슐화를 통해 객체 내부로의 접근을 제한하면 객체 사이의 결합도를 낮출 수 있게 되어 설계에 대한 쉬운 변경 가능
- `Theater`가 `TicketSeller`의 인터페이스에만 의존하도록 변경
- `TicketSeller`에서 `Bag`의 존재를 알지 못하도록 `Bag`에 대한 캡슐화
- 객체 내부의 상태를 캡슐화하고 객체 간 오직 메시지를 통해서만 상호작용하도록 설계
- `Audience`나 `TicketSeller`의 내부 변경이 `Theater`에 영향을 주지 않게 됨
    
### step - 3
- `Audience`가 `Bag`의 내부 상태를 알지 못하도록 변경
- `TicketOffice`이 자율성을 갖도록 구현
  - `TicketSeller`에서 `ticketOffice.getTicket()` 메서드 사용 대신 `TicketOffice`에 메시지를 던지도록 변경

## 결과
- `step - 3`의 경우 `TicketOffice`의 자율성은 높였지만<br>
`TicketOffice`와 `Audience` 간 의존성이 생김
- 트레이드오프를 고려한 적절한 설계 필요
- 요구사항은 항상 변경될 수 있기 때문에, 변경에 용이한 설계가 필요함
- 높은 결합도를 지닌 객체의 경우 수정되었을 때 버그를 동반할 가능성이 큼
- 객체 간 의존성을 적절하게 조절한 설계가 필요